Проектная работа по модулю
«SQL и получение данных»
(Группа DA-CP-2 Емельянова Лия)

1.	В работе использовался локальный тип подключения (восстановление из *.backup файла).

 






2.	Скриншот ER-диаграммы из D'Beaver.

 


3.	Краткое описание БД. 
Основной сущностью базы данных является бронирование (bookings).
     База данных состоит из 8 таблиц (aircrafts, airports, boarding_passes, bookings, flights, seats, ticket_flights, tickets), представления (flights_v) и материализованного представления (routes).
  
  
     4.	Развернутый анализ БД - описание таблиц, логики, связей и бизнес области.
     Бизнес область базы данных - авиаперевозки по России. 
Бронирование (bookings) является основной сущностью базы данных. Бронь (book_ref) может быть выписана как на одного, так и на нескольких пассажиров. В билете может быть несколько перелетов (flight_id), если между аэропортами маршрута нет прямых рейсов, либо билет «туда/обратно».
     Вся информация о перелетах содержится в таблице flights (номер рейса, аэропорт вылета/прилета, время вылета/прилета). Данные по аэропортам и городам их нахождения - таблица airports.
     При регистрации на рейс пассажиру выдается посадочный талон (boarding_no), в котором указывается место в самолете (seat_no). Пассажир может зарегистрироваться только на тот рейс, который есть у него в билете.  
     Данные о самолетах, количестве мест и их классах обслуживания содержатся в таблицах aircrafts и seats.
   4.1 (bookings). Пассажир заранее (book_date, максимум за месяц до рейса) бронирует (bookings) билет себе и, возможно, нескольким другим пассажирам. 
Бронирование идентифицируется номером (book_ref, шестизначная комбинация букв и цифр). Поле total_amount хранит общую стоимость включенных в бронирование перелетов всех пассажиров.
 
     4.2 (tickets). В одно бронирование можно включить несколько пассажиров, каждому из которых оформляется отдельный билет (tickets). Билет имеет 
уникальный номер (ticket_no), состоящий из 13 цифр, содержит идентификатор пассажира (passenger_id) — номер документа, удостоверяющего личность, — его фамилию и имя (passenger_name) и контактную информацию (contact_date).
 
     4.3 (ticket_flights). Билет включает один или несколько перелетов (ticket_flights). В схеме данных нет жесткого ограничения, но предполагается, 
что все билеты в одном бронировании имеют одинаковый набор перелетов. Перелет соединяет билет с рейсом и идентифицируется их номерами.
Для каждого перелета указываются его стоимость (amount) и класс обслуживания (fare_conditions).
 
     4.4 (flights). Каждый рейс (flights) следует из одного аэропорта (airports) в другой. Рейсы с одним номером имеют одинаковые пункты вылета и назначения, но будут отличаться датой отправления. Рейс всегда соединяет две точки - аэропорты вылета (departure_airport) и прибытия (arrival_airport). 
У каждого рейса есть запланированные дата и время вылета (scheduled_departure) и прибытия (scheduled_arrival). Реальные время вылета (actual_departure) и прибытия (actual_arrival) могут отличаться. Статус рейса (status) может принимать одно из следующих значений: Scheduled, On Time, Delayed, Departed, Arrived, Cancelled.
 
     4.5 (airports). Аэропорт идентифицируется трехбуквенным кодом (airport_code) и имеет свое имя (airport_name). Для города не предусмотрено отдельной сущности, но название (city) указывается и может служить для того, чтобы определить аэропорты одного города. Также указывается широта (longitude), долгота (latitude) и часовой пояс (timezone).
 
     4.6 (boarding_passes). При регистрации на рейс пассажиру выдается посадочный талон. Посадочным талонам присваиваются последовательные номера (boarding_no) в порядке регистрации пассажиров на рейс (этот номер будет уникальным только в пределах данного рейса). В посадочном талоне указывается номер места (seat_no).
 
     4.7 (seats). Количество мест (seats) в самолете и их распределение по классам обслуживания зависит от модели самолета (aircrafts), выполняющего рейс. Места определяют схему салона каждой модели. Каждое место определяется своим номером (seat_no) и имеет закрепленный за ним класс обслуживания (fare_conditions) — Economy, Comfort или Business.
 
     4.8 (aircrafts). Каждая модель воздушного судна идентифицируется своим трехзначным кодом (aircraft_code). Указывается также название модели (model) и максимальная дальность полета в километрах (range).
 
     4.9 Над таблицей flights создано представление flights_v, содержащее дополнительную информацию: расшифровку данных об аэропорте вылета (departure_airport, departure_airport_name, departure_city), расшифровку данных об аэропорте прибытия (arrival_airport, arrival_airport_name, arrival_city), местное время вылета (scheduled_departure_local, actual_departure_local), местное время прибытия (scheduled_arrival_local, actual_arrival_local), продолжительность полета (scheduled_duration, actual_duration).
 
     4.10 Таблица рейсов содержит избыточность: из нее можно было бы выделить информацию о маршруте (номер рейса, аэропорты отправления и назначения), которая не зависит от конкретных дат рейсов. Именно такая информация и составляет материализованное представление routes.
 

     Анализ информации БД помогает решить следующие бизнес-задачи:

     1. Анализ аэропортов - какие более нагружены, чтобы оптимизировать поток пассажиров.
     2. Какая часть билетов только бронируется, но не выкупается и, по каким направлениям.
     3. На каких рейсах процент мест в самолете остается свободным, чтобы провести оптимизацию, и сократить количество самолётов, летающих «впустую» (например, снижение пассажиропотока на таких направлениях).
     4. Выяснить какие маршруты самые популярные.
     5. Планирование закупки новых самолетов, исходя из предполагаемых маршрутов их использования.
     6. Продумать накопительную систему скидок для постоянных клиентов.
     






5. Список SQL запросов с описанием логики их выполнения:

= УСТАНАВЛИВАЕМ СОЕДИНЕНИЕ И ВЫБРАЕМ СХЕМУ BOOKINGS =
SET search_path = bookings;

1)  В каких городах больше одного аэропорта? – Москва и Ульяновск
      
       Для решения был использован запрос к таблице airports с применением агрегатной функции и группировки по столбцу city, далее сортировка.
Вариант решения 1:

select city from airports
group by city 
having count(city) > 1
order by city;

Вариант решения 2:

select a.airport_code as code,
 a.airport_name,
 a.city,
 a.longitude,
 a.latitude,
 a.timezone
from airports a
where a.city in (
 select aa.city
 from airports aa
 group by aa.city
 having count(*) > 1
 )
order by a.city, a.airport_code;

2)  В каких аэропортах есть рейсы, выполняемые самолетом с максимальной дальностью перелета? – Внуково, Домодедово, Кольцово, Пермь, Сочи, Толмачёво, Шереметьево.
       С помощью подзапроса находим самолёт с самой максимальной дальностью перелёта применяя ограничение LIMIT, затем с помощью оператора UNION объединяем таблицы flights_v и  aircrafts по коду самолёта анализируя аэропорта прибытия и отправления. 
select departure_airport, departure_airport_name 
from flights_v fv 
where fv.aircraft_code = (select a.aircraft_code from aircrafts a order by a."range" desc limit 1)
union
select arrival_airport, arrival_airport_name 
from flights_v fv 
where fv.aircraft_code = (select a.aircraft_code from aircrafts a order by a."range" desc limit 1);

3)  Вывести 10 рейсов с максимальным временем задержки вылета.
    
         В таблице flights вычисляем для каждого рейса время задержки вылета (от фактического отнимаем время вылета по расписанию) указывая обязательное условие is not null. Далее сортируем по убыванию информацию по задержке рейса и ограничиваем вывод до 10.

select 
  actual_departure - scheduled_departure as departure_delay, 
  flight_no,  
  departure_airport 
from flights 
where actual_departure - scheduled_departure is not null
order by departure_delay desc
limit 10;

4)  Были ли брони, по которым не были получены посадочные талоны?
       
       Чтобы получить информацию по бронированию с нулевыми значениями к основной таблице bookings присоединяем с помощью left join таблицы tickets и boarding_passes. Далее пишем условие что номер посадочного талона должен быть is null.

select b.book_ref, bp.boarding_no, bp.ticket_no  
from bookings b 
left join tickets t on b.book_ref = t.book_ref
left join boarding_passes bp on t.ticket_no = bp.ticket_no
where bp.boarding_no is null;



5)  Найдите количество свободных мест для каждого рейса, их % отношение к общему количеству мест в самолете.
Добавьте столбец с накопительным итогом - суммарное накопление количества вывезенных пассажиров из каждого аэропорта на каждый день. Т.е. в этом столбце должна отражаться накопительная сумма - сколько человек уже вылетело из данного аэропорта на этом или более ранних рейсах в течении дня.
      
       С помощью СТЕ находим общее количество мест в самолёте. Далее из общего количества мест вычитаем посадочные талоны на этом рейсе тем самым получаем свободные места. Чтобы получить процентное отношение к общему количеству - мы свободные места делим на общее количество мест и умножаем на 100. Применяем оконную функцию для подсчёта вылетевших за день из аэропорта людей.

with cte as (
	select s.aircraft_code, count(s.seat_no) as "count", a.model
	from seats s
	join aircrafts a on a.aircraft_code = s.aircraft_code 
	group by s.aircraft_code, a.model
)
select 
  departure_airport, 
  actual_departure , 
  cte."count" - count(bp.seat_no)  as available_seats,
  (((cte."count" - count(bp.seat_no))::numeric / cte."count")::numeric(32,2)) * 100 as percentage_of_available_seats,
  sum(count(bp.seat_no)) over (partition by f.actual_departure::date, f.departure_airport order by f.actual_departure) as cumulative_total
from boarding_passes bp
join flights f on f.flight_id = bp.flight_id
join cte on cte.aircraft_code = f.aircraft_code 
group by f.flight_id, cte."count";


6)  Найдите процентное соотношение перелетов по типам самолетов от общего количества.
       
       С помощью подзапроса считаем количество перелётов для каждого самолёта от их общего количества. Далее, используя значения, полученные в подзапросе, делим на оконную функцию для подсчёта общего количества перелётов и умножаем на 100. Таким образом находим процент от перелёта в рамках функции round.

select model, (round("count"::numeric / (sum("count") over ()), 2) * 100) as percentage_of_total_number_of_flights
from(
	select count(flight_id) as "count", model
	from flights f 
	join aircrafts a on a.aircraft_code = f.aircraft_code
	group by model
) f;


7)  Были ли города, в которые можно  добраться бизнес - классом дешевле, чем эконом-классом в рамках перелета?
       
       В первом СТЕ_1 выводим цену эконома в рамках перелёта, в СТЕ_2 выводим стоимость билета бизнес - класса в рамках перелёта. Агрегация нужна для нахождения максимальной цены билета для эконома и минимальной цены бизнес - класса в рамках перелёта. Далее пишем условие сравнения двух СТЕ и если условие выполнится, то выводим город.

with cte_1 as (
	select distinct tf.flight_id, max(amount) as price_econom, fare_conditions 
	from ticket_flights tf
	where tf.fare_conditions = 'Economy'
	group by flight_id, fare_conditions 
	order by flight_id
) ,
 cte_2 as (
	select distinct tf.flight_id, min(amount) as price_business , fare_conditions 
	from ticket_flights tf
	where tf.fare_conditions = 'Business'
	group by flight_id, fare_conditions 
	order by flight_id
)
select a.city as city_of_arrival
from cte_1
join cte_2 on cte_2.flight_id = cte_1.flight_id
join flights f on f.flight_id = cte_1.flight_id
join airports a on a.airport_code = f.arrival_airport
where price_business < price_econom;


8)  Между какими городами нет прямых рейсов?
       
С помощью декартово произведения (cross join) находим связи город – город. Используем оператор distinct чтобы убрать дубли Москвы и Ульяновска (так как там несколько аэропортов) и оператор where для того чтобы убрать связки городов на себя. Из представления flights_v выбираем города с рейсами и оператором except выводим конечный результат, указанный в задании (Точнее делаем представление (дубль flights_v с интересующими нас значениями)).

create view cities_v as
select v.departure_city, v.arrival_city
from flights_v v

select distinct a.city, a1.city
from airports a
cross join airports a1
where a.city != a1.city
  except
select c.departure_city, c.arrival_city
from cities_v c;


9)  Вычислите расстояние между аэропортами, связанными прямыми рейсами, сравните с допустимой максимальной дальностью перелетов  в самолетах, обслуживающих эти рейсы.

       С помощью СТЕ находим дистанцию между аэропортами - для этого берём данные из таблицы airports и связываем их с таблицей flight (аэропортом отправления и аэропортом прибытия (departure_airport и arrival_airport соответственно)). Далее вводим формулу, указанную в задании, и получаем расстояние между ними. Затем берём значения максимальной дальности полёта из таблицы aircrafts и проверяем «если максимальная дальность полёта больше чем дистанция маршрута то true если нет - false». Так же был использован оператор distinct так как надо отсечь дублирующие значения.

with cte as (
	select f.departure_airport, dep.longitude, dep.latitude, f.arrival_airport, arr.longitude, arr.latitude,
	f.arrival_airport, f.aircraft_code,
	round(((acos((sind(dep.latitude)*sind(arr.latitude) + cosd(dep.latitude) * cosd(arr.latitude) * cosd((dep.longitude - arr.longitude))))) * 6371)::numeric, 2)
	as distance_airports ,
	f.flight_no,
	dep.airport_name as departure_airport_name,
	arr.airport_name as arrival_airport_name
	from 
	flights f,
	airports dep,
	airports arr
	where f.departure_airport = dep.airport_code and f.arrival_airport = arr.airport_code
)
select distinct cte.departure_airport_name, cte.arrival_airport_name, cte.distance_airports,
a.range as aircraft_flight_distance,
case
when range > distance_airports
then 'Полёт прошёл удачно'
else 'КРУШЕНИЕ САМОЛЁТА'
end result
from aircrafts a 
join cte on cte.aircraft_code = a.aircraft_code
